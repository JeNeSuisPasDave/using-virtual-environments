# parse_version()
#
# A function to convert a Python or Ruby version string into a normalized
# form having major, minor, and patch number, along with optional qualifier
# (like 'p123' or 'a1' or 'rc1' or 'pre').
#
parse_version() {
  if [[ 2 < $# ]]; then
    echo "ERROR: too many arguments for 'parse_version()'."
    return 1
  fi
  if [ -z "$1" ]; then
    echo "ERROR: missing version string for 'parse_version()'."
    return 1
  fi

  # Initialize result and local variables
  #
  local STD_VSN_=( "0" "0" "0" "" )
  IFS_SAVE_="${IFS}"
  parse_version=( ${STD_VSN_[@]} )

  # Split the version into tokens
  #
  local IFS='.'
  local VSN_ARRAY_=($1)
  IFS="${IFS_SAVE_}"

  # Assemble the normalized version number
  #
  local VSN_ARRAY_LEN_=${#VSN_ARRAY_[@]}
  RE_SUB_MATCH='^([0-9]+)[.-]?.*$'
  RE_SUB_='s/^([0-9]+)[.-]?.*$/\1/'
  RE_SUB2_='s/^[0-9]*[.-]?(.+)$/\1/'
  if (( 4 <= $VSN_ARRAY_LEN_ )); then
    # assuming 9.9.9.9
    STD_VSN_[0]=${VSN_ARRAY_[0]}
    STD_VSN_[1]=${VSN_ARRAY_[1]}
    STD_VSN_[2]=${VSN_ARRAY_[2]}
    STD_VSN_[3]=${VSN_ARRAY_[3]}
  elif (( 3 == $VSN_ARRAY_LEN_ )); then
    # assuming 9.9.9 or 9.9.9-p123 or 9.9p123
    STD_VSN_[0]=${VSN_ARRAY_[0]}
    STD_VSN_[1]=${VSN_ARRAY_[1]}
    if [[ ${VSN_ARRAY_[2]} =~ ${RE_SUB_MATCH} ]]; then
      STD_VSN_[2]=`echo ${VSN_ARRAY_[2]} | sed -E ${RE_SUB_}`
    fi
    STD_VSN_[3]=`echo ${VSN_ARRAY_[2]} | sed -E ${RE_SUB2_}`
  elif (( 2 == $VSN_ARRAY_LEN_ )); then
    # assuming 9.9 or 9.9-p123 or 9p123
    STD_VSN_[0]=${VSN_ARRAY_[0]}
    if [[ ${VSN_ARRAY_[1]} =~ ${RE_SUB_MATCH} ]]; then
      STD_VSN_[1]=`echo ${VSN_ARRAY_[1]} | sed -E ${RE_SUB_}`
    fi
    STD_VSN_[3]=`echo ${VSN_ARRAY_[1]} | sed -E ${RE_SUB2_}`
  elif (( 1 == $VSN_ARRAY_LEN_ )); then
    # assuming 9 or 9-p123
    if [[ ${VSN_ARRAY_[0]} =~ ${RE_SUB_MATCH} ]]; then
      STD_VSN_[0]=`echo ${VSN_ARRAY_[0]} | sed -E ${RE_SUB_}`
    fi
    STD_VSN_[3]=`echo ${VSN_ARRAY_[0]} | sed -E ${RE_SUB2_}`
  else
    # unexpected format or empty string
    return 1
  fi

  # Set global $parse_version to result and
  # get out
  #
  parse_version=( ${STD_VSN_[@]} )
  return 0
}

# version_is_at_least()
#
# A function to extract a version from a string and check that it
# meets or exceeds an expected version.
#
# First argument is the expected version number string.
# Second argument is the string containing a version number.
#
version_is_at_least() {
  # Make sure an expected version string got passed
  #
  if [ -z "$1" ]; then
    echo "ERROR: missing expected version for 'version_is_at_least()'."
    return 0
  fi
  if [ -z "$2" ]; then
    echo "ERROR: missing actual version for 'version_is_at_least()'."
    return 0
  fi
  if [ ! -z "$3" ]; then
    echo "ERROR: too many arguments for 'version_is_at_least()'."
    return 0
  fi

  EXP_=$1
  ACT_=$2

  # Tokenize the expected version
  #
  parse_version "${EXP_}"
  if (( 0 != $? )); then
    echo "ERROR: failed to parse expected version '$EXP_'"
    exit 2
  fi
  EXP_PARTS_=( ${parse_version[@]} )
  EXP_MAJOR_=${EXP_PARTS_[0]}
  EXP_MINOR_=${EXP_PARTS_[1]}
  EXP_PATCH_=${EXP_PARTS_[2]}
  EXP_QUAL_=${EXP_PARTS_[3]}

  # Tokenize the actual version
  #
  parse_version "${ACT_}"
  if (( 0 != $? )); then
    echo "ERROR: failed to parse actual version '$ACT_'"
    exit 2
  fi
  ACT_PARTS_=( ${parse_version[@]} )
  ACT_MAJOR_=${ACT_PARTS_[0]}
  ACT_MINOR_=${ACT_PARTS_[1]}
  ACT_PATCH_=${ACT_PARTS_[2]}
  ACT_QUAL_=${ACT_PARTS_[3]}

  # Test the actual versus expected version. If actual is >= expected
  # then return 1; else, return 0.
  #
  OK_=1
  if (( ${EXP_MAJOR_} > ${ACT_MAJOR_} )); then
    OK_=0
  elif (( ${EXP_MAJOR_} == ${ACT_MAJOR_} )); then
    if (( ${EXP_MINOR_} > ${ACT_MINOR_} )); then
      OK_=0
    elif (( ${EXP_MINOR_} == ${ACT_MINOR_} )); then
      if (( ${EXP_PATCH_} > ${ACT_PATCH_} )); then
        OK_=0
      elif (( ${EXP_PATCH_} == ${ACT_PATCH_} )); then
        if (( ${EXP_QUAL_} > ${ACT_QUAL_} )); then
          OK_=0
        fi
      fi
    fi
  fi

  # Get out
  #
  echo ${OK_}
  return 0
}

# version_is_less_than()
#
# A function to extract a version from a string and check that it
# is below maximum version.
#
# First argument is the maximum version number string.
# Second argument is the string containing a version number to test.
#
version_is_less_than() {
  # Make sure an maximum version string got passed
  #
  if [ -z "$1" ]; then
    echo "ERROR: missing maximum version for 'version_is_less_than()'."
    return 0
  fi
  if [ -z "$2" ]; then
    echo "ERROR: missing actual version for 'version_is_less_than()'."
    return 0
  fi
  if [ ! -z "$3" ]; then
    echo "ERROR: too many arguments for 'version_is_less_than()'."
    return 0
  fi

  MAX_=$1
  ACT_=$2

  # Tokenize the maximum version
  #
  parse_version "${MAX_}"
  if (( 0 != $? )); then
    echo "ERROR: failed to parse maximum version '$MAX_'"
    exit 2
  fi
  MAX_PARTS_=( ${parse_version[@]} )
  MAX_MAJOR_=${MAX_PARTS_[0]}
  MAX_MINOR_=${MAX_PARTS_[1]}
  MAX_PATCH_=${MAX_PARTS_[2]}
  MAX_QUAL_=${MAX_PARTS_[3]}

  # Tokenize the actual version
  #
  parse_version "${ACT_}"
  if (( 0 != $? )); then
    echo "ERROR: failed to parse actual version '$ACT_'"
    exit 2
  fi
  ACT_PARTS_=( ${parse_version[@]} )
  ACT_MAJOR_=${ACT_PARTS_[0]}
  ACT_MINOR_=${ACT_PARTS_[1]}
  ACT_PATCH_=${ACT_PARTS_[2]}
  ACT_QUAL_=${ACT_PARTS_[3]}

  # Test the actual versus maximum version. If actual is >= maximum
  # then return 1; else, return 0.
  #
  OK_=0
  if (( ${MAX_MAJOR_} > ${ACT_MAJOR_} )); then
    OK_=1
  elif (( ${MAX_MAJOR_} == ${ACT_MAJOR_} )); then
    if (( ${MAX_MINOR_} > ${ACT_MINOR_} )); then
      OK_=1
    elif (( ${MAX_MINOR_} == ${ACT_MINOR_} )); then
      if (( ${MAX_PATCH_} > ${ACT_PATCH_} )); then
        OK_=1
      elif (( ${MAX_PATCH_} == ${ACT_PATCH_} )); then
        if (( ${MAX_QUAL_} > ${ACT_QUAL_} )); then
          OK_=1
        fi
      fi
    fi
  fi

  # Get out
  #
  echo ${OK_}
  return 0
}
